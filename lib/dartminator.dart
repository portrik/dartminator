import 'dart:convert' show utf8;
import 'dart:io' as io;
import 'dart:isolate';
import 'dart:async';

import 'package:grpc/grpc.dart';

import 'package:dartminator/generated/dartminator.pbgrpc.dart';

import 'computation.dart';
import 'constants.dart';
import 'logger.dart';

class DartminatorNode extends NodeServiceBase {
  /// Logger instance.
  var logger = getLogger();

  /// Name of the node, usually automatically generated by Faker.
  String name;

  /// Port to be discovered/discover child nodes on.
  int discoveryPort;

  /// Upper limit of possible child connections.
  int maxChildren;

  /// List of the current child nodes.
  final List<io.InternetAddress> _children = [];

  // The currently computed argument
  String? _currentArgument;

  // The current result but the parent has stopped responding
  String? _strandedResult;

  /// Type of the computation
  final Computation _computation;

  /// Is the current node in a computation?
  bool _isComputing = false;

  DartminatorNode(
      this.name, this.discoveryPort, this.maxChildren, this._computation) {
    logger.i('Created Node $name for the ${_computation.name} computation.');
  }

  /// Initializes the node to be used on the network.
  ///
  /// Prepares the node to be used over the local network for computation.
  /// This means listening for incoming connections to a computation.
  Future init() async {
    await listenForConnections();
  }

  /// Starts the computation on this node and redistributes arguments to child nodes.
  ///
  /// Starts the computation as the root node.
  ///
  /// [seed] is the starting argument for the computation.
  ///
  /// Returns the result of the computation.
  Future<String> start(String seed) async {
    logger.i('Starting the computation with seed $seed.');

    var results = await compute(_computation.getArguments(seed));
    var composed = await _computation.finalizeResult(results);

    logger
        .i('All of the computations are completed. The result is: $composed.');

    return composed;
  }

  /// Computes all of the results on this node and potential child nodes.
  ///
  /// [arguments] is the list of arguments to compute through.
  ///
  /// Returns the list of results from this and child nodes.
  ///
  /// The computation assigns work to this node and any potential nodes until
  /// the all of the arguments are processed. In case of a node failure, the
  /// argument is reassigned to another node.
  ///
  /// Child nodes are searched for during each assignment cycle. This has to be
  /// done because the child node detaches itself from the tree as a leaf.
  /// The tree has to be then reconstructed with the same or even different nodes.
  Future<List<String>> compute(List<String> initialArguments) async {
    var arguments = [...initialArguments];
    logger.i('Starting the computation of ${arguments.length} chunks.');
    logger.i('The starting arguments are: $arguments');
    _isComputing = true;

    // The result array is generated with empty strings.
    List<String> results = [];

    logger.i('Looking for stranded nodes.');
    for (var argument in arguments) {
      // Look for stranded nodes until the timeout is reached
      await findStranded(argument).timeout(childSearchTimeout, onTimeout: () {
        logger.d('No stranded node found in time.');
      });
    }
    logger.i(
        'The search for stranded nodes has finished with ${_children.length} nodes.');

    logger.i('Looking for child nodes.');
    // Looks for children until the timeout is reached
    await findChildren(maxChildren).timeout(
      childSearchTimeout,
      onTimeout: () {
        logger.d(
            'The child search has finished with ${_children.length} child nodes.');
      },
    );
    logger.i(
        'Child search has finished. ${_children.length} child nodes are attached.');

    var workers = <Future<dynamic>>[];

    var mainCompleter = Completer();
    var mainPort = ReceivePort();

    Map<String, dynamic> mainData = {};
    mainData['port'] = mainPort.sendPort;
    mainData['computation'] = _computation;

    mainPort.listen((data) {
      Map<String, dynamic> response = data;
      SendPort isolatePort = response['port'];
      String? argument = response['argument'];
      String? result = response['result'];

      // Register valid result
      if (result != null) {
        results.add(result);
        logger.i(
            'New result from the main computation. ${(initialArguments.length - results.length) + 1} chunks remaining.');
      } else if (argument != null) {
        // Re-add failed argument
        arguments.add(argument);
      }

      // Send new argument, if any are available
      if (arguments.isNotEmpty) {
        String argument = arguments.removeAt(0);
        isolatePort.send(argument);
      } else {
        // Close the port if no more work is available
        isolatePort.send(null);
        mainPort.close();
      }
    }, onDone: () => mainCompleter.complete());
    workers.add(mainCompleter.future);
    await Isolate.spawn(handleMainComputation, mainData);

    List<Map<String, dynamic>> childData = [];
    for (var child in _children) {
      var childCompleter = Completer();
      var port = ReceivePort();

      Map<String, dynamic> data = {};
      data['port'] = port.sendPort;
      data['child'] = child;

      port.listen((data) {
        Map<String, dynamic> response = data;
        SendPort? isolatePort = response['port'];
        String? argument = response['argument'];
        String? result = response['result'];

        // If port is null, the child node is not reachable.
        if (isolatePort == null) {
          port.close();
        } else {
          // Register valid result
          if (result != null) {
            results.add(result);
            logger.i(
                'New result from a child computation. ${(initialArguments.length - results.length) + 1} chunks remaining.');
          } else if (argument != null) {
            // Re-add failed argument
            arguments.add(argument);
          }

          // Send new argument, if any are available
          if (arguments.isNotEmpty) {
            String argument = arguments.removeAt(0);
            isolatePort.send(argument);
          } else {
            _children.remove(child);
            // Close the port if no more work is available
            isolatePort.send(null);
            port.close();
          }
        }
      }, onDone: () => childCompleter.complete());
      workers.add(childCompleter.future);
      childData.add(data);
    }

    // Spawning isolates in a separate loop since they modify the length of _children
    for (var data in childData) {
      await Isolate.spawn(handleChildComputation, data);
    }

    await Future.wait(workers);

    _isComputing = false;
    logger.i('Finished the main computation.');

    return results;
  }

  /// Tries to find any stranded node with a finished computation of an argument.
  ///
  /// [argument] is the argument that the potential strandee has computed.
  ///
  /// Sends out a message to check if any orphaned node has computed with the
  /// argument. If a node responds, the result of the computation is taken and
  /// the node is added as a child and thus re-introduced to the computation.
  Future<String?> findStranded(String argument) async {
    logger.d('Starting the search for potentially stranded nodes.');

    var socket = await io.RawDatagramSocket.bind(io.InternetAddress.anyIPv4, 0);
    socket.broadcastEnabled = true;
    socket.readEventsEnabled = true;

    String? result;

    var stream = socket.listen((event) {
      try {
        if (event == io.RawSocketEvent.read) {
          var response = socket.receive();

          if (response != null) {
            var responseType = utf8.decode(response.data).split('-')[1];
            var computationType = utf8.decode(response.data).split('-').last;

            if (responseType == 'Stranded' &&
                computationType == _computation.name) {
              result = utf8.decode(response.data).split('-')[2];

              _children.add(response.address);
              socket.close();
            }
          }
        }
      } catch (err, stacktrace) {
        logger.e(
            'Could not parse incoming message during stranded search!\n$err\n$stacktrace');
      }
    }).asFuture();

    // Sends out the broadcast message with it's own name as a computation invitation.
    socket.send(
        'Dartminator-Strandees-$argument-Computation${_computation.name}'
            .codeUnits,
        io.InternetAddress("255.255.255.255"),
        discoveryPort);

    // Waits for the stream to finish.
    await stream;

    return result;
  }

  /// Tries to find a child nodes for the computation on the local network.
  ///
  /// [limit] upper limit of the children to register.
  ///
  /// Sends out a broadcast message over the local network with a computation invite.
  /// Any responder that is not this node and is not already registered as a child
  /// is added to the list. The listening port is closed after reaching [limit].
  Future findChildren(int limit) async {
    logger.d('Starting the search for children.');

    // Socket used to send and receive messages
    // Port 0 is used to prevent clashes with the discoveryPort
    var socket = await io.RawDatagramSocket.bind(io.InternetAddress.anyIPv4, 0);
    socket.broadcastEnabled = true;
    socket.readEventsEnabled = true;

    // A stream handling the communication with potential children.
    // asFuture is used to synchronize the behavior with other async functions.
    var stream = socket.listen((event) {
      try {
        if (event == io.RawSocketEvent.read) {
          var response = socket.receive();

          if (response != null) {
            var responseType = utf8.decode(response.data).split('-')[1];

            if (responseType == 'Name') {
              var responderName = utf8.decode(response.data).split('-')[2];

              logger.d(
                  'Child Search: Got response from $responderName at ${response.address}');

              // Prevents from connecting to self
              // To already connected node
              // Or reaching the connection limit
              if (responderName != name &&
                  !_children.contains(response.address) &&
                  _children.length < maxChildren) {
                logger.i(
                    'Adding $responderName at ${response.address} to children!');

                _children.add(response.address);

                // Closes the socket as it is not needed anymore.
                if (_children.length >= limit) {
                  socket.close();
                }
              }
            }
          }
        }
      } catch (err, stacktrace) {
        logger.e(
            'Could not parse incoming message during child search!\n$err\n$stacktrace');
      }
    }).asFuture();

    // Sends out the broadcast message with it's own name as a computation invitation.
    socket.send(
        'Dartminator-Name-$name-Computation${_computation.name}'.codeUnits,
        io.InternetAddress("255.255.255.255"),
        discoveryPort);

    // Waits for the stream to finish.
    await stream;
  }

  /// Starts listening to potential computations.
  ///
  /// Starts a socket listening to possible computation invitations on [discoveryPort].
  /// Any response incoming from a node with a different name is responded to.
  Future listenForConnections() async {
    // Socket used exclusively for listening to computation invites.
    var socket = await io.RawDatagramSocket.bind(
        io.InternetAddress.anyIPv4, discoveryPort);
    socket.readEventsEnabled = true;

    logger.i('Listening for potential computation on port $discoveryPort.');

    socket.listen((event) {
      try {
        if (event == io.RawSocketEvent.read) {
          var response = socket.receive();

          if (response != null) {
            logger.d(
                'Computation listening response: ${utf8.decode(response.data)}');

            var requestType = utf8.decode(response.data).split('-')[1];

            if (requestType == 'Name') {
              // Checks the inviters name and computation type
              var inviter = utf8.decode(response.data).split('-')[2];
              var computation = utf8
                  .decode(response.data)
                  .split('-')[3]
                  .split('Computation')[1];

              if (inviter != name &&
                  computation == _computation.name &&
                  !_isComputing) {
                logger.d(
                    'Found a new potential computation from $inviter at ${response.address}.');

                socket.send('Dartminator-Name-$name'.codeUnits,
                    response.address, response.port);
              }
            } else if (requestType == 'Strandees') {
              var argument = utf8.decode(response.data).split('-')[2];

              if (argument == _currentArgument) {
                socket.send('Dartminator-Stranded-$_strandedResult'.codeUnits,
                    response.address, response.port);

                _currentArgument = null;
                _strandedResult = null;
                _isComputing = false;
              }
            }
          }
        }
      } catch (err, stacktrace) {
        logger.e(
            'Could not parse response during computation listening!\n$err\n$stacktrace');
      }
    });
  }

  /// Handles the gRPC communication with a child node.
  ///
  /// [data] is a map of the arguments. A map is used due to the limitations of
  /// Isolates. [data] consists of: a ReceivePort used for communication with the
  /// parent Isolate, InternetAddress of the child to communicate with and the
  /// argument the child will use during the computation.
  ///
  /// Opens a gRPC channel with the child and handles the stream of responses.
  /// In case the child is already in another computation or the connection fails,
  /// null is sent back to the main Isolate through the port. Otherwise the handler
  /// waits for the result of the computation and returns it through the port.
  static Future handleChildComputation(Map<String, dynamic> data) async {
    // A separate logger instance is needed since Isolates do not have access
    // to closure and memory of the parent Isolate.
    var logger = getLogger();

    SendPort responsePort = data['port'];

    ReceivePort port = ReceivePort();
    responsePort
        .send({'argument': null, 'result': null, 'port': port.sendPort});

    logger.d('Started child handler for ${data['child']}.');

    try {
      // Creates the gRPC channel on the port 50051 with no credentials
      ClientChannel clientChannel = ClientChannel(data['child'],
          port: grpcPort,
          options: ChannelOptions(
              credentials: ChannelCredentials.insecure(),
              connectionTimeout: grpcCallTimeout));

      // Creates the Dartminator Node stub to use for communication
      NodeClient child = NodeClient(clientChannel,
          options: CallOptions(timeout: grpcCallTimeout));

      await for (var argument in port) {
        logger.i('Argument: $argument');

        if (argument == null) {
          break;
        }

        try {
          var responses =
              child.initiate(ComputationArgument(argument: argument));

          // Listens to the response stream from the child node
          await for (var response in responses) {
            logger.d('Response from child ${data['child']}: $response');

            if (response.empty) {
              logger
                  .w('The child ${data['child']} is already in a computation!');
              break;
            }

            if (response.result.done) {
              logger.d(
                  'The child ${data['child']} has finished with ${response.result.result}.');

              responsePort.send({
                'argument': argument,
                'result': response.result.result,
                'port': port.sendPort
              });
            }
          }
        } catch (err, stacktrace) {
          logger
              .e('The connection with a child has failed!\n$err\n$stacktrace');
          responsePort.send(
              {'argument': argument, 'result': null, 'port': port.sendPort});
        }
      }

      // Shuts the gRPC channel gracefully.
      await clientChannel.shutdown();
    } catch (err, stacktrace) {
      logger.e('The connection with a child has failed!\n$err\n$stacktrace');
      responsePort.send({'argument': null, 'result': null, 'port': null});
    }
  }

  /// Handles the main computation.
  ///
  /// [data] is a map of the arguments. A map is used due to the limitations of
  /// Isolates. [data] consists of: a ReceivePort used for communication with the
  /// parent Isolate, the Computation object, and the argument the child will
  ///  use during the computation.
  ///
  /// Starts the computation and awaits its completion. In case of a failure,
  /// a null is sent back to the main Isolate.
  static Future handleMainComputation(Map<String, dynamic> data) async {
    // A separate logger instance is needed since Isolates do not have access
    // to closure and memory of the parent Isolate.
    var logger = getLogger();

    SendPort responsePort = data['port'];
    Computation computation = data['computation'];

    ReceivePort port = ReceivePort();
    responsePort
        .send({'argument': null, 'result': null, 'port': port.sendPort});

    await for (var argument in port) {
      if (argument == null) {
        break;
      }

      try {
        logger.d('Starting main node computation from the argument $argument.');

        var result = await computation.compute(argument);

        logger.d(
            'This node\'s computation has completed with the result $result.');

        responsePort.send(
            {'argument': argument, 'result': result, 'port': port.sendPort});
      } catch (err, stacktrace) {
        logger
            .e('The main computation has thrown an error!\n$err\n$stacktrace');
        responsePort.send(
            {'argument': argument, 'result': null, 'port': port.sendPort});
      }
    }

    responsePort.send({'argument': null, 'result': null, 'port': null});
    port.close();
  }

  /// Implements the gRPC function for communication between nodes.
  @override
  Stream<ComputationHeartbeat> initiate(
      ServiceCall call, ComputationArgument request) async* {
    logger.i('Heartbeat request: $request');

    // The node is already working. Returns an empty response.
    if (_isComputing) {
      logger.i(
          'Received a heartbeat request while in a computation. Returning empty response.');

      yield ComputationHeartbeat(empty: true);
    }

    logger.i('Starting the computation as a child.');
    List<String> results = [];
    _currentArgument = request.argument;
    compute(_computation.getArguments(request.argument))
        .then((res) => results = res);

    // Returns a heartbeat until the computation is finished.
    // The delay between heartbeats is set by calculationTimeout.
    while (results.isEmpty) {
      logger.i(
          'Still computing. Returning an empty heartbeat and waiting for $heartbeatTimeout.');

      var response = await Future.delayed(heartbeatTimeout,
          () => ComputationHeartbeat(result: ComputationResult(done: false)));

      if (results.isEmpty) {
        break;
      }

      yield response;
    }

    String result = await _computation.finalizeResult(results);

    logger.i('Finished computation. Returning result to the parent.');
    _strandedResult = result;

    // The computation has finished. Returning the result.
    yield ComputationHeartbeat(
        result: ComputationResult(done: true, result: result));
  }

  /// Exposes the computing status.
  bool isComputing() => _isComputing;

  /// Exposes the count of currently connected children.
  int connectedChildren() => _children.length;
}
